/**
 * This script provides utility functions shared across other checkout scripts.
 * Reused script components for checkout should be contained here, while this
 * script is imported into the requiring script.
 */
importPackage( dw.customer );
importPackage( dw.order );
importPackage( dw.system );
importPackage( dw.util );
importPackage( dw.value );
importPackage( dw.crypto );

/**
 * Calculates the amount to be payed by a non-gift certificate payment instrument based 
 * on the given basket. The method subtracts the amount of all redeemed gift certificates 
 * from the order total and returns this value.
 */
function calculateNonGiftCertificateAmount( basket : Basket ) 
{
	// the total redemption amount of all gift certificate payment instruments in the basket
	var giftCertTotal : Money = new Money( 0.0, basket.currencyCode );

	// get the list of all gift certificate payment instruments 
	var gcPaymentInstrs : Collection = basket.getGiftCertificatePaymentInstruments();
	var iter : Iterator = gcPaymentInstrs.iterator();
	var orderPI : OrderPaymentInstrument = null;

	// sum the total redemption amount
	while( iter.hasNext() )
	{
		orderPI = iter.next();
		giftCertTotal = giftCertTotal.add( orderPI.getPaymentTransaction().getAmount() );
	}

	// get the order total
	var orderTotal : Money = basket.totalGrossPrice;

	// calculate the amount to charge for the payment instrument
	// this is the remaining open order total which has to be paid
	var amountOpen : Money = orderTotal.subtract( giftCertTotal );

	// return the open amount
	return amountOpen;
}

/**
 * Determines a unique shipment ID for shipments in the given basket
 * and the given base ID. The function appends a counter to the base ID
 * and checks the existence of the resulting ID. If the resulting ID is
 * unique this ID is returned, if not the counter is incremented and
 * checked again.
 */
function determineUniqueShipmentID( basket : Basket, baseID : String )
{
	var counter : Number = 1;
	var shipment : Shipment = null;
	var candidateID : String = baseID + "" + counter;
	while( shipment == null )
	{
		shipment = basket.getShipment(candidateID);
		if( shipment != null )
		{
			// this ID is already taken, increment the counter 
			// and try the next one
			counter++;
			candidateID = baseID + "" + counter;
			shipment = null;
		}
		else
		{
			return candidateID;
		}
	}
	
	// should never go here
	return null;
}

/**
 * Transient representation of a shipping address.
 */
function ShippingAddress()
{
	var UUID : String = null;

	var ID 			: String = null;
	var firstName 	: String = null;
	var lastName 	: String = null;
	var address1 	: String = null;
	var address2 	: String = null;
	var city 		: String = null;
	var postalCode 	: String = null;
	var stateCode 	: String = null;
	var countryCode : String = null;
	var phone 		: String = null;

	/**
	 * The UUID of the reference address. It is set when the attributes
	 * are copied from a given customer or order address and is used
	 * to preselect addresses on a per product line item base.
	 */
	var referenceAddressUUID : String = null;

	/**
	 * Copies the attributes of this address to the given order address.
	 */ 
	this.copyTo = function( toAddress : OrderAddress )
	{
		toAddress.setFirstName( this.firstName );
		toAddress.setLastName( this.lastName );
		toAddress.setAddress1( this.address1 );
		toAddress.setAddress2( this.address2 );
		toAddress.setCity( this.city );
		toAddress.setPostalCode( this.postalCode );
		toAddress.setStateCode( this.stateCode );
		toAddress.setCountryCode( this.countryCode );
		toAddress.setPhone( this.phone );
	}

	/**
	 * Copies the attributes from the given customer address or
	 * order address to this address. The function supports both
	 * copying from CustomerAddress as well as from OrderAddress.
	 */
	this.copyFrom = function( fromAddress : CustomerAddress )
	{
		// if we copy from a customer address, we set the address ID
		if( fromAddress instanceof CustomerAddress )
		{
			this.ID = fromAddress.ID;
		}
		
		this.firstName = fromAddress.firstName;
		this.lastName = fromAddress.lastName;
		this.address1 = fromAddress.address1;
		this.address2 = fromAddress.address2;
		this.city = fromAddress.city;
		this.postalCode = fromAddress.postalCode;
		this.stateCode = fromAddress.stateCode;
		this.countryCode = fromAddress.countryCode;
		this.phone = fromAddress.phone;
	}
}

/**
 * Creates a new transient shipping address in the session dictionary.
 */
function createShippingAddress( referenceAddress : CustomerAddress )
{
	// create a new in memory address and set the UUID
	var address : Object = new ShippingAddress();
	address.UUID = UUIDUtils.createUUID();

	// get all addresses from session dictionary
	var addresses : Collection = session.custom.shippingAddresses;

	// create an empty array, if no collection was found in session dictionary
	if( addresses == null )
	{
		addresses = new ArrayList();
		session.custom.shippingAddresses = addresses;
	}

	// add the address to the collection
	addresses.add( address );

	// copy the attribute of the reference address to the transient address
	

	return address;
}

/**
 * Finds a transient shipping address in the session dictionary
 * and returns the found address.
 */
function findShippingAddress( uuid : String )
{
	// check if uuid is set
	if( empty(uuid) )
	{
		return null;
	}

	// get all addresses from session dictionary
	var addresses : Collection = session.custom.shippingAddresses;

	// check if there are addresses at all
	if( addresses == null || addresses.size() == 0 )
	{
		return null;
	}

	// find the address
	for(var i=0; i<addresses.size(); i++)
	{
		if( uuid.equals(addresses[i].UUID) )
		{
			return addresses[i];
		}	
	}

	return null;
}

/**
 * Removes a transient shipping address from the session dictionary.
 */
function removeShippingAddress( shippingAddress : Object )
{
	// check if shippingAddress is set
	if( empty(shippingAddress) )
	{
		return;
	}

	// get all addresses from session dictionary
	var addresses : Collection = session.custom.shippingAddresses;

	// check if there are addresses at all
	if( addresses == null || addresses.size() == 0 )
	{
		return;
	}

	// remove the object from the collection
	addresses.remove( shippingAddress );

	return;
}

/** 
 * Determines if the basket already contains payment 
 * instruments of the given payment method and removes them from the basket.
 */
function removeExistingPaymentInstruments( basket : Basket, method : String )
{
	// get all credit card payment instruments
	var ccPaymentInstrs : Collection = basket.getPaymentInstruments( method );
	var iter : Iterator = ccPaymentInstrs.iterator();
	var existingPI : OrderPaymentInstrument = null;

	// remove them
	while( iter.hasNext() )
	{
		existingPI = iter.next();
		basket.removePaymentInstrument( existingPI );
	}
}

